---
# tasks file for letsencrypt-dns01    

- local_action: file name="{{ host_specific_files }}/crypto" state=directory mode=0700 recurse=yes

# the host addresses should go in the inventory file; since we are updating dns and not
# gathering facts, the source of truth is the inventory file
#
# the "approved" way to set these is ansible_v4host and ansible_v6host (which belong to us) not
# ansible_host which belongs to ansible - probably ought to reevaluate the namespace here.
# nevertheless, if only ansible_host is set, we'll try to run with it.
#
# it is fine, btw, to have hosts with no A or AAAA records for them at all.  these hosts will
# just get a txt record, no ip address.  applications may include updating a bind view that
# faces LetsEncrypt's nameservers for the purposes of genning up certs for internal devices.

- name: nsupdate A record for inventory_hostname_short
  local_action:
    module: nsupdate
    key_algorithm: "{{ nsupdate_hmac }}"
    key_name: "{{ nsupdate_key_name }}"
    key_secret: "{{ nsupdate_key_secret }}"
    server: "{{ nsupdate_server }}"
    zone: "{{ inventory_hostname.split('.', 1)[1] }}"
    record: "{{ inventory_hostname_short }}"
    type: A
    value: "{{ ansible_host }}"
  when: ansible_host != "localhost" and ansible_v4host is not defined and ansible_v6host is not defined

- name: nsupdate A record for ansible_v4host (if defined in inventory)
  local_action:
    module: nsupdate
    key_algorithm: "{{ nsupdate_hmac }}"
    key_name: "{{ nsupdate_key_name }}"
    key_secret: "{{ nsupdate_key_secret }}"
    server: "{{ nsupdate_server }}"
    zone: "{{ inventory_hostname.split('.', 1)[1] }}"
    record: "{{ inventory_hostname_short }}"
    type: A
    value: "{{ ansible_v4host }}"
  when: ansible_v4host is defined 

- name: nsupdate AAAA record for ansible_v4host (if defined in inventory)
  local_action:
    module: nsupdate
    key_algorithm: "{{ nsupdate_hmac }}"
    key_name: "{{ nsupdate_key_name }}"
    key_secret: "{{ nsupdate_key_secret }}"
    server: "{{ nsupdate_server }}"
    zone: "{{ inventory_hostname.split('.', 1)[1] }}"
    record: "{{ inventory_hostname_short }}"
    type: AAAA
    value: "{{ ansible_v6host }}"
  when: ansible_v6host is defined

- name: check if cert key exists
  local_action:
    module: stat
    path: "{{ host_specific_files }}/crypto/server.key"
  register: cert_key_stat
  
- name: openssl private key (specific to this cert)
  local_action:
    module: openssl_privatekey
    path: "{{ host_specific_files }}/crypto/server.key"
    passphrase: "{{ openssl_passphrase | default(omit) }}"
    cipher: "{{ 'AES-256-CBC' if openssl_passphrase is defined else omit }}"
    type: RSA
    size: 2048
  when: cert_key_stat.stat.exists == False

- name: check if master playbook account key exists
  local_action:
    module: stat
    path: "files/account.key"
  register: account_key_stat
  
- name: create master playbook ACME account key if not already existing
  local_action:
    module: openssl_privatekey
    path: "files/account.key"
    passphrase: "{{ openssl_passphrase | default(omit) }}"
    cipher: "AES-256-CBC"
    size:  4096
  run_once: true
  when: account_key_stat.stat.exists == False

- name: looking for per-host override to account.key
  local_action:
    module: set_fact
    acme_account_key_file: "{{ lookup('first_found', acme_keypath)}}"
  vars:
    acme_keypath:
      - "{{ host_specific_files }}/crypto/account.key"
      - "files/account.key"

- debug:
    var: acme_account_key_file

#- debug:
#    var: "{{ lookup('ssl_key_text', acme_account_key_file, passphrase=openssl_passphrase) }}"
    
- name: Make sure account exists and has given contacts. We agree to TOS.
  local_action:
    module: acme_account
    account_key_src: "{{ omit if openssl_passphrase is defined else acme_account_key_file }}"
    account_key_content: "{{ lookup('ssl_key_text', acme_account_key_file, passphrase=openssl_passphrase) if openssl_passphrase is defined else omit }}"
    state: present
    terms_agreed: yes
    acme_directory: "https://{{ which_ca }}/directory"
    acme_version: 2
    contact:
      - "mailto:{{cert_emailaddress}}"
  run_once: true

- name: making a certificate signing request
  local_action:
    module: openssl_csr
    email_address: "{{ cert_emailaddress }}"
    common_name: "{{ inventory_hostname }}"
    subject_alt_name: "{{ subject_alt_names | default(omit) }}"
    path: "{{ host_specific_files }}/crypto/server.csr"
    privatekey_path: "{{ host_specific_files }}/crypto/server.key" 
    privatekey_passphrase: "{{ openssl_passphrase | default(omit) }}"

- name: getting a challenge from {{ which_ca }} to put in the DNS
  local_action:
    module: acme_certificate
    account_key_src: "{{ omit if openssl_passphrase is defined else acme_account_key_file }}"
    account_key_content: "{{ lookup('ssl_key_text', acme_account_key_file, passphrase=openssl_passphrase) if openssl_passphrase is defined else omit }}"
    account_email: "{{ cert_emailaddress }}"
    src: "{{ host_specific_files }}/crypto/server.csr"
    cert: "{{ host_specific_files }}/crypto/server.crt"
    challenge: dns-01
    acme_directory: "https://{{ which_ca }}/directory"
    acme_version: 2
    # Renew if the certificate is at least 30 days old
    force: "{{ force_cert_renew | default(false) }}"
    remaining_days: "{{ cert_renew_days }}"
  register: dnschallenge


# WARNING:  the way the rr value here is crawled out of the response is potentially brittle af because of the -
# thanks acme guys and yaml parser writers.  

- name: putting the challenge we got for CNs in the DNS
  local_action:
    module: nsupdate
    key_algorithm: "{{ nsupdate_hmac }}"
    key_name: "{{ nsupdate_key_name }}"
    key_secret: "{{ nsupdate_key_secret }}"
    server: "{{ nsupdate_server }}"
    zone: "{{ acmecnamezone | default(inventory_hostname.split('.', 1)[1]) }}"
    record: "_acme-challenge.{{ inventory_hostname if acmecnamezone is defined else inventory_hostname_short }}"
    type: TXT
    value: "{{ dnschallenge.challenge_data.get(inventory_hostname)['dns-01'].resource_value }}"
  when: "dnschallenge.changed == true"


# unfortunately unchanged subjectaltname list in the host_vars file is not idempotent; you'll
# get a dns update message for each of them, but this should be harmless.

- name: putting challenges we got for any SubjectAltNames in the DNS
  local_action:
    module: nsupdate
    key_algorithm: "{{ nsupdate_hmac }}"
    key_name: "{{ nsupdate_key_name }}"
    key_secret: "{{ nsupdate_key_secret }}"
    server: "{{ nsupdate_server }}"
    zone: "{{ acmecnamezone | default(item.split('.', 1)[1]) }}"
    record: "_acme-challenge.{{ item.split(':', 1)[1] if acmecnamezone is defined else item.split(':', 1)[1].split('.')[0] }}"
    type: TXT
    value: "{{ dnschallenge.challenge_data.get(item.split(':', 1)[1])['dns-01'].resource_value }}"
  with_items: "{{ subject_alt_names }}"
  when: dnschallenge.changed == true and subject_alt_names is defined

- name: asking {{ which_ca }} to sign our certs
  local_action:
    module: acme_certificate
    account_key_src: "{{ omit if openssl_passphrase is defined else acme_account_key_file }}"
    account_key_content: "{{ lookup('ssl_key_text', acme_account_key_file, passphrase=openssl_passphrase) if openssl_passphrase is defined else omit }}"
    account_email: "{{ cert_emailaddress }}"
    src: "{{ host_specific_files }}/crypto/server.csr"
    cert: "{{ host_specific_files }}/crypto/server.crt"
    fullchain: "{{ host_specific_files }}/crypto/server-fullchain.crt"
    chain: "{{ host_specific_files }}/crypto/server-intermediate.crt"
    challenge: dns-01
    acme_directory: "https://{{ which_ca }}/directory"
    remaining_days: "{{ cert_renew_days }}"
    force: "{{ force_cert_renew | default(false) }}"
    acme_version: 2
    data: "{{ dnschallenge }}"
  when: "dnschallenge.changed == true"

# clean up the mess
- name: getting rid of challenge TXT records for CNs
  local_action:
    module: nsupdate
    key_algorithm: "{{ nsupdate_hmac }}"
    key_name: "{{ nsupdate_key_name }}"
    key_secret: "{{ nsupdate_key_secret }}"
    server: "{{ nsupdate_server }}"
    zone: "{{ acmecnamezone | default(inventory_hostname.split('.', 1)[1]) }}"
    record: "_acme-challenge.{{ inventory_hostname if acmecnamezone is defined else inventory_hostname_short }}"
    type: TXT
    value: "{{ dnschallenge.challenge_data.get(inventory_hostname)['dns-01'].resource_value }}"
    state: absent
  when: "dnschallenge.changed == true"

- name: getting rid of challenge TXT records for SubjectAltNames
  local_action:
    module: nsupdate
    key_algorithm: "{{ nsupdate_hmac }}"
    key_name: "{{ nsupdate_key_name }}"
    key_secret: "{{ nsupdate_key_secret }}"
    server: "{{ nsupdate_server }}"
    zone: "{{ acmecnamezone | default(item.split('.', 1)[1]) }}"
    record: "_acme-challenge.{{ item.split(':', 1)[1] if acmecnamezone is defined else item.split(':', 1)[1].split('.')[0] }}"
    type: TXT
    value: "{{ dnschallenge.challenge_data.get(item.split(':', 1)[1])['dns-01'].resource_value }}"
    state: absent
  with_items: "{{ subject_alt_names }}"
  when: dnschallenge.changed == true and subject_alt_names is defined


...
