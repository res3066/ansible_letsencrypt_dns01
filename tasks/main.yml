---
# tasks file for letsencrypt-dns01    

- name: validate configuration
  fail:
    msg: need either acmeservers or route53 working
  when:
    - aws_key is not defined 
    - acmeservers is not defined

- name: validate account
  include_tasks: account-setup.yml

- name: Making sure crypto subdirectory is present
  file:
    name: "{{ host_specific_files }}/crypto"
    state: directory
    mode: 0700
    recurse: yes
  delegate_to: localhost

# SEE README.md for discussion of the {{ acmecnamezone }} variable and why it is a
# good workflow
#
# it is fine, btw, to have hosts with no A or AAAA records for them at all.  these hosts will
# just get a txt record, no ip address.  applications may include updating a bind view that
# faces LetsEncrypt's nameservers for the purposes of genning up certs for internal devices.

- name: Check for existance of the CNAME if using acmecnamezone (expect skip when healthy!)
  fail: msg="can't find CNAME for _acme-challenge.{{ cert_hostname | replace('*.','') }}"
  when: acmecnamezone is defined and lookup('dig', '_acme-challenge.' + cert_hostname | replace('*.',''), 'qtype=CNAME')=="NXDOMAIN"

- name: Check for existance of the CNAME if using acmecnamezone and SAN (expect skip when healthy!)
  fail: msg="can't find CNAME for _acme-challenge.{{ item.split(':', 1)[1] | replace('*.','') }}"
  when: subject_alt_names is defined and acmecnamezone is defined and
    lookup('dig', '_acme-challenge.'+ item.split(':', 1)[1] | replace('*.',''), 'qtype=CNAME')=="NXDOMAIN"
  with_items: "{{ subject_alt_names }}"

- name: create key if necessary using local storage
  block:
    - name: check if cert key exists
      stat:
        path: "{{ host_specific_files }}/crypto/server.key"
      delegate_to: localhost
      register: cert_key_stat

    - name: openssl private key (specific to this cert)
      openssl_privatekey:
        path: "{{ host_specific_files }}/crypto/server.key"
        passphrase: "{{ openssl_passphrase | default(omit) }}"
        cipher: "{{ 'auto' if openssl_passphrase is defined else omit }}"
        type: RSA
        size: 2048
      delegate_to: localhost
      when: not cert_key_stat.stat.exists
  when: vault_cert_mount is not defined
  
- name: create key if necessary using vault
  block:
    - name: check if cert key exists
      community.hashi_vault.vault_read:
        path: "{{ vault_cert_path }}/{{ inventory_hostname }}"
      register: existing
      ignore_errors: yes

    - name: openssl private key (specific to this cert)
      command: "openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:2048"
      register: new_key
      when: existing.data.data.data['server-key'] is not defined
    
    - name: store openssl private key if new
      community.hashi_vault.vault_write:
        path: "{{ vault_cert_path }}/{{ inventory_hostname }}"
        data:
          data:
            "server-key": "{{ new_key.stdout }}"
      when: new_key.changed 

    - name: set existing key
      set_fact:
        vault_host_key: "{{ existing.data.data.data['server-key'] }}"
        vault_host_csr: "{{ existing.data.data.data['server-csr'] | default(omit) }}"
        vault_host_cert: "{{ existing.data.data.data['server-cert'] | default(omit) }}"
        vault_host_fullchain: "{{ existing.data.data.data['server-fullchain'] | default(omit) }}"
        vault_host_intermediate: "{{ existing.data.data.data['server-intermediate'] | default(omit) }}"
        vault_host_san: "{{ existing.data.data.data['san'] | default(omit) }}"
        vault_host_ca: "{{ existing.data.data.data['ca'] | default(omit) }}"
      when: not new_key.changed

    - name: set existing key
      set_fact:
        vault_host_key: "{{ new_key.stdout }}"
      when: new_key.changed
  when: vault_cert_mount is defined
  delegate_to: localhost

- name: make the CSR (local)
  block:
    - name: making a certificate signing request
      openssl_csr:
        email_address: "{{ cert_emailaddress }}"
        common_name: "{{ cert_hostname }}"
        subject_alt_name: "{{ subject_alt_names | default(omit) }}"
        path: "{{ host_specific_files }}/crypto/server.csr"
        privatekey_path: "{{ host_specific_files }}/crypto/server.key"
        privatekey_passphrase: "{{ openssl_passphrase | default(omit) }}"
      register: csrresults

    - name: if we created a new csr (configuration changed), all existing certs are invalid
      file:
        path: "{{ host_specific_files }}/crypto/{{ item }}"
        state: absent
      with_items:
        - server-fullchain.crt
        - server-intermediate.crt
        - server.crt
      when: csrresults.changed
  when: vault_cert_mount is not defined
  delegate_to: localhost

- name: make the CSR (vault)
  block:
#    - name: check existing CSR
#      openssl_csr_info: 
#        content: "{{ vault_host_csr }}"
#      register: vault_csr_info
#      when: vault_host_csr is defined
    - name: force SAN if none
      set_fact:
        subject_alt_names:
          - "DNS:{{ cert_hostname }}"
      when: subject_alt_names is not defined

    - name: create CSR if its not the same content (SAN)
      command:
        cmd: "openssl req -new -key /dev/stdin -subj '/CN={{ cert_hostname }}' -addext subjectAltName={{ subject_alt_names | join(',') }}"
        stdin: "{{ vault_host_key }}"
      register: new_csr
      # when: vault_csr_info is skipped or (vault_csr_info.subject_alt_name| join(",")) != (subject_alt_names | join(','))
      when: vault_host_san is not defined or subject_alt_names != vault_host_san or vault_host_ca is not defined or vault_host_ca != which_ca

    - name: store openssl csr if new
      community.hashi_vault.vault_write:
        path: "{{ vault_cert_path }}/{{ inventory_hostname }}"
        data:
          data:
            "server-key": "{{ vault_host_key }}"
            "server-csr": "{{ new_csr.stdout }}"
            "san": "{{ subject_alt_names }}"
      when: new_csr.changed 

    - name: store new csr
      set_fact:
        vault_host_csr: "{{ new_csr.stdout }}"
        vault_host_san: "{{ subject_alt_names | default(omit) }}"
        force_cert_renew: yes
      when: new_csr.changed
    
  when: vault_cert_mount is defined
  delegate_to: localhost

- name: getting a challenge from {{ which_ca }} to put in the DNS (local)
  acme_certificate:
    account_key_src: "{{ omit if openssl_passphrase is defined else acme_account_key_file }}"
    account_key_content: "{{ lookup('ssl_key_text', acme_account_key_file, passphrase=openssl_passphrase) if openssl_passphrase is defined else omit }}"
    account_email: "{{ cert_emailaddress }}"
    src: "{{ host_specific_files }}/crypto/server.csr"
    cert: "{{ host_specific_files }}/crypto/server.crt"
    challenge: dns-01
    acme_directory: "https://{{ which_ca }}/directory"
    acme_version: 2
    # Renew if force_cert_renew variable set OR if the CSR changed
    # HOPEFULLY this shuts up ansible-lint and doesn't break anything RS 2020-08-06
# old line:    force: "{{ force_cert_renew | default( (csrresults['changed'] == true) | ternary('yes','no') ) }}"
# becomes new line below:
    force: "{{ force_cert_renew | default( (csrresults['changed']) | ternary('yes','no') ) }}"
    # Renew if the certificate has less than N days left on it (best practice says default probably 30)
    remaining_days: "{{ cert_renew_days }}"
  delegate_to: localhost
  register: dnschallenge_local
  when: vault_cert_mount is not defined

- name: prepare for vault renewal/cert
  block:
    - name: clear out old cert
      file:
        path: "{{ host_specific_files }}/crypto/{{ item }}"
        state: absent
      with_items:
        - server-fullchain.crt
        - server-intermediate.crt
        - server.crt

    # can skip this is we just use the expiration in the cert data
    - name: copy in cert if we have it
      copy:
        content: "{{ vault_host_cert }}"
        dest: "{{ host_specific_files }}/crypto/server.crt"
        mode: '0600'
      when: vault_host_cert is defined

    - name: getting a challenge from {{ which_ca }} to put in the DNS (vault)
      acme_certificate:
        account_key_content: "{{ vault_account_key }}"
        account_email: "{{ cert_emailaddress }}"
        csr_content: "{{ vault_host_csr }}"
        cert: "{{ host_specific_files }}/crypto/server.crt"
        challenge: dns-01
        acme_directory: "https://{{ which_ca }}/directory"
        acme_version: 2
        force: "{{ force_cert_renew | default( (new_csr.changed) | ternary('yes','no') ) }}"
        # Renew if the certificate has less than N days left on it (best practice says default probably 30)
        remaining_days: "{{ cert_renew_days }}"
      register: dnschallenge_vault
  delegate_to: localhost
  when: vault_cert_mount is defined

- name: set dnschallenge
  set_fact:
    dnschallenge: "{{ dnschallenge_vault if dnschallenge_local is skipped else dnschallenge_local }}"

# Preemptively getting rid of any existing TXT records.
# Note that you can not do an update if a record of RRTYPE exists at said node.
# Important for when you're debugging something that blew up in the past and left
# cruft in the DNS - you'll be wondering why you can't catch a break...

- name: clear up prior TXT records (nsupdate)
  include_tasks: clean-dns-nsupdate.yml
  when:
    - acmeservers is defined
    - dnschallenge.changed

#- name: clear up prior TXT records (route53)
#  include_tasks: clean-dns-route53.yml
#  when: aws_key is defined and dnschallenge.changed

# WARNING:  the way the rr value here is crawled out of the response is potentially brittle af because of the -
# thanks acme guys and yaml parser writers.  

- name: add challenges (nsupdate)
  include_tasks: add-challenge-nsupdate.yml
  when:
    - acmeservers is defined
    - dnschallenge.changed

- name: add challenges (route53)
  include_tasks: add-challenge-route53.yml
  when: aws_key is defined and dnschallenge.changed

- name: asking {{ which_ca }} to sign our certs (local)
  acme_certificate:
    account_key_src: "{{ omit if openssl_passphrase is defined else acme_account_key_file }}"
    account_key_content: "{{ lookup('ssl_key_text', acme_account_key_file, passphrase=openssl_passphrase) if openssl_passphrase is defined else omit }}"
    account_email: "{{ cert_emailaddress }}"
    src: "{{ host_specific_files }}/crypto/server.csr"
    cert: "{{ host_specific_files }}/crypto/server.crt"
    fullchain: "{{ host_specific_files }}/crypto/server-fullchain.crt"
    chain: "{{ host_specific_files }}/crypto/server-intermediate.crt"
    challenge: dns-01
    acme_directory: "https://{{ which_ca }}/directory"
    remaining_days: "{{ cert_renew_days }}"
    force: "{{ force_cert_renew | default(false) }}"
    acme_version: 2
    data: "{{ dnschallenge }}"
  delegate_to: localhost
  when: dnschallenge_local.changed

- name: sign and store certs (vault)
  block:
    - name: asking {{ which_ca }} to sign our certs (vault)
      acme_certificate:
        account_key_content: "{{ vault_account_key }}"
        account_email: "{{ cert_emailaddress }}"
        csr_content: "{{ vault_host_csr }}"
        cert: "{{ host_specific_files }}/crypto/server.crt"
        challenge: dns-01
        acme_directory: "https://{{ which_ca }}/directory"
        remaining_days: "{{ cert_renew_days }}"
        force: "{{ force_cert_renew | default(false) }}"
        acme_version: 2
        data: "{{ dnschallenge }}"
        retrieve_all_alternates: yes
      register: certs_signed
      when: dnschallenge_vault.changed
    
    - name: debug
      debug:
        var: certs_signed

    - name: get expiration date
      community.crypto.x509_certificate_info:
        content: "{{ certs_signed.all_chains[0].cert }}"
      when: certs_signed.changed
      register: cert_info

    - name: store results if changed
      community.hashi_vault.vault_write:
        path: "{{ vault_cert_path }}/{{ inventory_hostname }}"
        data:
          data:
            "server-key": "{{ vault_host_key }}"
            "server-csr": "{{ vault_host_csr }}"
            "san": "{{ vault_host_san }}"
            "server-cert": "{{ certs_signed.all_chains[0].cert }}"
            "server-fullchain": "{{ certs_signed.all_chains[0].full_chain }}"
            "server-intermediate": "{{ certs_signed.all_chains[0].chain }}"
            "notafter": "{{ cert_info.not_after }}"
            "ca": "{{ which_ca }}"
      when: certs_signed.changed 

    - name: remove cert
      file:
        path: "{{ host_specific_files }}/crypto/server.crt"
        state: absent
  delegate_to: localhost
  when:  dnschallenge_vault.changed

- name: clean up the mess (nsupdate)
  include_tasks: clean-dns-nsupdate.yml
  when:
    - acmeservers is defined
    - dnschallenge.changed

- name: clean up the mess (route53)
  include_tasks: clean-dns-route53.yml
  when: aws_key is defined and dnschallenge.changed
